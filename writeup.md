# COMP6447 Fuzzer

## 22T2 Major Project Submission

### Simon Blain (z5200681) | Liam Godfrey (z5256175) | Avin Singh (z5222179) | Jin Shan Ho (z5230926)
-------------------------------------
## How the fuzzer works

The fuzzer was designed to be composed of two major parts:

* The harness, which is the overarching object that passes input through to the binary, monitoring for crashes or other interesting changes, and presents information about what has been done to the user.
* The Fuzzer, which generates input based on the file type (along with general fuzzing techniques) with the intent to adapt the input based on feedback from the monitor.


## Harness

-------------------------------------

The harness as the primary component, passes input through to the binary and monitors for changes and crashes, as well as presents this data in a readable format to the user. The harness itself can be broken down into two separate components - GDB integration, and verification.

When the harness is first run, a number of threads are generated, each running their own instance of the core fuzzing engine where, as well as two other threads that have the sole responsibility of filling the queue with input from the fuzzer engine.

If GDB integration is enabled, a GDB instance is spawned, identifying all input functions and other functions and setting temporary and persistent breakpoints, with the intention of identifying new code-paths discovered. Checkpoints are also created, with the intention of speeding up the fuzzing process by jumping back in memory to before user input was supplied - rather than running the code from the top every time.

From here, the GDB instance runs in a loop until either the thread is killed (because a vulnerability was found, or the session was canceled by the user) or the program crashes. If the program crashes, the payload that crashed it, along with the error code are sent back to the main region of the thread where the payload is run again through the binary to verify that the error is correct and can be recreated. If the payload does indeed crash the binary, all threads are shut down, and the output is saved to bad.txt. If the payload was a false positive, however, the thread simply loops back, spawning a new GDB instance and picking up from where it left off.

If GDB is disabled, however, then each input generated by the fuzzing engines is passed straight through to the ‘verification’ section that checks if the binary crashes. While this does test significantly more fuzzer-engine-generated input, code coverage and feedback to the fuzzing engines and user are limited.


## Fuzzer

-------------------------------------

The fuzzer is implemented through fuzzer class objects specifically defined for each binary type, built off a generic fuzzer class template. We have used this object-oriented style of programming so as to encourage reusability of code. This is especially so for fuzzers which produce mutations off similar logic. 

### Type Detection

The fuzzer first takes in the input (seed) file and detects the binary type by parsing the file for specific patterns. It immediately creates the fuzzing object which is passed to the harness, ready to generate new mutations. 

### Mutation Strategies

These are the basic strategies for each successfully implemented fuzzer. 
(Note) Due to lack of time and resources, we were unable to implement the Plaintext fuzzer.

| Input Type | Known Ints | Known 'Bad' Bytes | Bit Flips | Byte Flips | Replacement | Duplication |
|:----------:|:----------:|:-----------------:|:---------:|:----------:|:-----------:|:-----------:|
|     CSV    |      Y     |         Y         |     N     |      N     |      Y      |      N      |
|    JSON    |      Y     |         Y         |     Y     |      Y     |      Y      |      N      |
|     XML    |      Y     |         Y         |     Y     |      Y     |      Y      |      Y      |
|     JPG    |      N     |         Y         |     Y     |      Y     |      Y      |      N      |

#### **Known Values**
The most commonly used strategy across all fuzzers is known values. Such known calues are integers, floats or characters which are known to be troublesome if the binary is unable to parse them well. This includes the testing of integer overflow/underflows, by using INT_MAX and INT_MIN as well as incredibly large input values to cause buffer overflows. 

Examples:
- 0, -1, 1.5, 0x80000000, 0xffffffff, ...
- %s, %p, ...

#### **Bit/Byte Flips**
Bit flips are effective in drastically changing string values. This strategy is used the most in JPG fuzzer, where the mutable input is in the form of a bytearray. However, the issue with bit flips are its inefficiency, especially when dealing with bytearrays of large sizes. Simply changing a single bit out of hundreds of thousands of bits in a bytearray might potentially result in a bad input, but the probability of achieving this result in infinitesimally small. It is because of this observation that more bits should be changed at one go to optimise the fuzzer, and this is where ratio-flipping and byte-flipping comes into play. Byte flipping increases the odds of finding a bad input, and implementing a ratio flip where a defined proportion of bits/bytes are flipped at one go is another attempt at optimisation. However, a particular drawback is that with a higher proportion of bytes flipped, the likelihood of corrupting the type-specific bytearray format is greater by order of magnitude. Therefore, finding a safe ratio and monitoring the probability of executing the ratio strategy is important, so as to find a balance between generating bad input and generating input with higher probability of inciting a binary crash. 


#### **XML Fuzzer**
Fuzzing XML input is several times more challenging than of the other input types here, because of its structure and more complicated syntax. In order to generate effective mutations, we utilised 3 main strategies, the latter two of which were inspired by CENSUS' 2015 presentation on fuzzing methods and observations. [Source](https://census-labs.com/media/choronzon-zeronights-2015.pdf)
1.  Depth/Breadth-wise insertion of elements to potentially trigger stack overflow error in binary or XML parser
*   nesting multiple elements
*   creating multiple children in parent nodes
2.  Chromosome Recombination
*   Restructuring of XML tree
*   addition/removal/replacement/duplication of nodes
*   copying content from one element to another
*   moving content from one element to another
3.  Heirarchial Recombination
*   Restructuring of XML tree
*   Redefining node heirarchies
Implementation of these strategies and their sub-strategies can generate effective mutations. However, we observe that the need to iterate through the tree to access parent and children nodes might cause some drop in fuzzer performance.


#### **JPG Fuzzer**
Implementing the JPG fuzzer requires a deeper understanding of binary file types. In order to identify a binary file as JPG, PNG, etc., these files contain signature bytes, either at the beginning or end of the file, or both. JPG's SOI and EOI markers are at both ends, hence some care must be taken when fuzzing so as to not overwrite these bytes. One specific strategy used in this fuzzer is 'magic bytes' where random locations in the input are overwritten with these values. These 'magic bytes' are actually of the same concept as Known Values, because they are notorious for causing errors when in the right place. 











### Harness
The harness is capable of two separate ‘modes’ - GBD mode and native mode
#####GBD Mode
GDB Mode is the default mode of operation for the fuzzer. In this mode, the harness spawns a GDB instance within which the selected binary is run. GDB mode is intended offer the following features:

 * In memory resetting
 * Code paths
 * Code coverage metrics
 * Crash type detection
 * Infinte loop detection

In memory resetting is performed by catching the program before it exits as a result of benign fuzzed input and automatically jumping back to the beginning of the binary's execution path. This prevents the continuous calling of execve and avoids associated system calls. In memory resetting is achieved through the use of a breakpoint on the \_exit function and associated commands that immeditalely return the instruction pointer to _start.

Code paths are traced whenever a function is called for the first time. A backtrace is performed to identify the the path which led the binary to this location in the code. A hash of this path is taken and if unique the hash is added to the list of unique paths. This operation is extended to determine code coverage metric. As the total number of functions in the binary are identified when initialised, the number of functions the binary then hits can be compared to the total number of functions in the binary to calculate code coverage.

Crash type detection is achieved by intercepting and parsing GDB messages to identify the cause of the crash. This is then communicated back to the harness monitor when shutting down.

Infinite loop detection is identified when rate of new code points seen reduced to zero for a defined amount of time. This indicates that previous paths in the code are continuously being traverse and the fuzzer is potentially caught in a loop. This is differentiated from simply running slowly as slow performance is identified by the rate at which fuzzing input is injected into the binary.

##### Native Mode
Native mode if an optional mode that fuzzes the binary directly instead of running on top of GDB. When compared to GDB Mode, Native Mode offers the following benefits:

 * High performance
 * Crash type detection
 * Support for binaries that required EOF

Because of the lower overheads of executing natively, Native Mode provides much higher performance than GDB Mode, injecting inputs at approximately thirty-times the rate of GBD Mode. However it does not offer the code coverage and infinite loop detection that GDB Mode offers.

Like GDB Mode, Native Mode is able to detect the type of crash that occured when an input is able to crash the binary.

Some binaries require an EOF signal to properly receive and process the fuzzed input. GDB is not able to send such a signal so the binary is left waiting for more input and hangs. Native Mode avoids this situation as an EOF if automatically sent with the input. For those binaries requiring files types that need an EOF, the harness automatically runs in Native Mode, this is not configurable.



## Future Improvements

The following a list of features that could not be fully implemented but would improve the performance an effectiveness of the fuzzer:

 * Improved In Memory Resetting
    * The fuzzer currently catches the binary when it is attempting to exit and returns it to the beginning of its execution. Being able to identify return points of functions receieving data and returning to their calls to reduce the number of redundant steps withing GBD would improve performance in GDB mode. Checkpoints were implemented in the fuzzer in order to faciliate this, taking a snapshot whenever a function like fgets() is called but the ability to return to these checkpoints has not been implemented.
 * Monitoring Critical Locations in Memory
    * The ability to identify and monitor criticial locations in memory using the GDB watchpoints feature would allow more sophisticated monitoring of the binaries than just monitor and identifying crashes.
 * EOF Support in GDB
    * Being able to run binaries that require EOFs for inputs in GDB would allow the features of GDB Mode to be available for these binaries.
 * Wider Binary Support
    * We did not have the time to complete the fuzzing engines for all necessary binaries.
 * More effective fuzzing strategies
    * Some of the strategies used were general methods used. However, these methods are not very effective. For example, if an arithmetic strategy does not work, there is no point in randomising values over a very large range when a only a small range of values is required to check if it can cause the binary to crash. 
 * Better communication between the fuzzer and the harness
    * the fuzzer could have been greatly optimised if we could implement better communication and detection functionality between it and the harness.
    * this could have improved execution path discovery by a significant extent if we are able to quickly identify the strategies with greater success rate. 


------------------

